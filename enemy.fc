options ( bank: 1 );
use math;
use util;
use common;

/*********************************************
 * 敵関係のルーチン
 *********************************************/

/** 初期化する */
function en_init():void
{
	var i:int;
	en_bul_free = 0;
	for( i, 0, EN_BUL_MAX ){
		en_bul_x[i] = i+1;
	}
}

function en_process():void
{
	var i:int;
	// 敵の出現
	if( en_wait == 0 ){
		if( rand() % 8 == 0 ){
			billy_new();
		}else{
			en_1_new();
		}
		en_wait = 30+rand()/4;
	}else{
		en_wait -= 1;
	}

	for( i, 0, EN_MAX ){
		var type = en_type[i];
		EN_PROCESS[type](i);
	}
}

function en_new():int
{
	var i:int;
	for( i, 0, EN_MAX ){
		if( !en_type[i] ){ return i; }
	}
	return 255;
}

// 敵の弾の処理
function en_bul_process():void;

/**
 * 新しい敵の弾を生成して、そのインデックスを返す.
 * 取得できなかった場合は、255を返す
 */
function en_bul_new():int
{
	if( en_bul_free >= EN_BUL_MAX ){ return 255; }
	var n = en_bul_free;
	en_bul_free = en_bul_x[en_bul_free];
	return n;
}

/**
 * 角度を指定して玉を打つ
 */
function en_bul_new_angle( x:int, y:int, angle:int, speed:int ):void
{
	var n = en_bul_new();
	if( n == 255 ){ return; }
	en_bul_type[n] = 1;
	en_bul_x[n] = x;
	en_bul_y[n] = y;
	en_bul_vx[n] = cos(angle)/speed;
	en_bul_vy[n] = -sin(angle)/speed;
}

/**
 * 角度を指定して玉を打つ
 */
function en_bul_nway( x:int, y:int, angle:int, speed:int, way:int, spread:int ):void
{
	var i:int;
	angle = angle - (way*spread)/2;
	for( i, 0, way ){
		var n = en_bul_new();
		if( n == 255 ){ return; }
		en_bul_type[n] = 1;
		en_bul_x[n] = x;
		en_bul_y[n] = y;
		en_bul_vx[n] = cos(angle)/speed;
		en_bul_vy[n] = -sin(angle)/speed;
		angle += spread;
	}
}

/** 敵と自機の弾の当たり判定を行う */
function en_check_hit(i:int):int
{
	var j:int;
	for( j, 0, MY_BUL_MAX ){
		if( my_bul_type[j] == 1 && en_x[i] + 12 - my_bul_x[j] < 24 && en_y[i] + 12 - my_bul_y[j] < 24 ){
			my_bul_type[j] = 2;
			my_bul_vx[j] = 0;
			return 1;
		}
	}
	return 0;
}

/*********************************************
 * ダミー
 *********************************************/
function en_none_process(i:int):void {}

/*********************************************
 * 敵１
 *********************************************/
const SPR_ENEMY = 0xc0;

function en_1_new():int
{
	var i = en_new();
	if( i != 255 ){
		en_type[i] = 1;
		en_x[i] = rand()/2 + 64;
		en_y[i] = 16;
		en_p1[i] = 0;
		en_p2[i] = 0;
		en_p4[i] = 4;
	}
	return i;
}

function en_1_process(i:int):void
{
	var pal:int = 1;

	// 自機の弾との当たり判定
	if( en_check_hit(i) ){
		en_p4[i] -= 1;
		pal = 0;
		if( en_p4[i] == 0 ){
			en_type[i] = 0;
			return;
		}
	}

	switch( en_p1[i] ){
	case 0:
		en_y[i] += 2;
		en_p2[i] += 1;
		if( en_p2[i] == 40 ){
			en_p1[i] = 1;
			en_p2[i] = 0;
			en_p3[i] = atan( -(my_y/16 - en_y[i]/16), my_x/16 - en_x[i]/16 );
		}
	case 1:
		en_p2[i] += 1;
		// 弾を打つ
		if( en_p2[i] % 32 == 0 ){
			var angle = atan( -(my_y/16 - en_y[i]/16), my_x/16 - en_x[i]/16 );
			// en_bul_new_angle( en_x[i], en_y[i], angle, 6 );
			var x = en_p2[i] / 32 % 2;
			en_bul_nway( en_x[i], en_y[i], angle, 6, 3+x, 12 );
		}
		if( en_p2[i] == 120 ){
			en_p1[i] = 2;
		}
	case 2:
		en_x[i] -= cos(en_p3[i])/32;
		en_y[i] += sin(en_p3[i])/32;
		if( outside( en_x[i], en_y[i] ) ){
			en_type[i] = 0;
			return;
		}
	}

	// 表示
	gr_sprite2x2( en_x[i]-8, en_y[i]-8, SPR_ENEMY, pal );

}

/*********************************************
 * ビリー・ヘリントン
 *********************************************/

const BILLY_NORMAL:int[] = [0x80, 0x81, 0x82, 0x83,
							0x90, 0x91, 0x92, 0x93,
							0xA0, 0xA1, 0xa2, 0xa3,
							0xb0, 0xb1, 0xb2, 0xb3 ];

const BILLY_SMOKE:int[] = [0x84, 0x85, 0x86, 0x87,
						   0x94, 0x95, 0x96, 0x97,
						   0xa4, 0xa5, 0xa6, 0xa7,
						   0xb4, 0xb5, 0xb6, 0xb7 ];

const BANG:int[] = [0x88, 0x89, 0x98, 0x99,
					0x8a, 0x8b, 0x9a, 0x9b,
					0x8c, 0x8d, 0x9c, 0x9d,
					0x8e, 0x8f, 0x9e, 0x9f,
					0x00, 0x00, 0x00, 0x00 ];

function billy_new():int
{
	var i = en_new();
	if( i != 255 ){
		var cy = (ppu_scroll2 / 8 + 4)%30;
		var cx = rand() % 24 + 4;
		
		en_type[i] = 2;
		en_x[i] = cx * 8;
		en_p1[i] = 0;
		en_p2[i] = cy; // スクロール上の位置
		en_p4[i] = 0;
	}
	return i;
}

function billy_process(i:int):void
{
	// 画面上の位置を計算
	var y = en_p2[i] * 8;
	if( y > ppu_scroll2 ){
		y = y - ppu_scroll2;
	}else{
		y = 240 + y - ppu_scroll2;
	}
	en_y[i] = y;
	
	// 自機の弾との当たり判定
	var p1 = en_p1[i];
	if( p1 != 255 && en_check_hit(i) ){
		en_p4[i] -= 1;
		if( en_p4[i] == 0 ){
			en_p1[i] = 255;
			return;
		}
	}

	var p4 = en_p4[i];
	var cx = en_x[i]/8;
	var cy = en_p2[i];
	if( p1 == 0 ){
		if( p4 % 4 == 0 ){
			gr_print( cx-2,cy, &BILLY_SMOKE[(p4/4%4)*4], 4, 1 );
		}
		if( p4 % 16 == 0 ){
			p4 = p4 / 16;
			if( p4 < 3 ){
				gr_print( cx-2,cy-1-p4, BILLY_NORMAL, 4, p4+1 );
			}else{
				gr_print( cx-2,cy-3, BILLY_NORMAL, 4, 4 );
				en_p1[i] = 2;
				en_p4[i] = 16;
			}
		}
		en_p4[i] += 1;
	}elsif( p1 == 255 ){
		// 死亡時
		if( p4 % 4 == 0 ){
			p4 = p4 / 4;
			if( p4 < 13 ){
				bang( cx-1,cy-2, p4 );
				bang( cx  ,cy-3, p4-2 );
				bang( cx  ,cy-1, p4-4 );
				bang( cx-2,cy-3, p4-6 );
				bang( cx-2,cy-1, p4-8 );
			}else{
				// 削除
				en_type[i] = 0;
			}
		}
		en_p4[i] += 1;
	}
	
	if( outside( 120/*適当*/, y ) ){
		en_type[i] = 0;
		return;
	}

	// 表示
	// gr_sprite2x2( en_x[i]-8, y-8, SPR_BILLY, 0 );

}

function bang( cx:int, cy:int, n:int):void
{
	if( n < 5 ){
		gr_print( cx, cy, &BANG[n*4], 2, 2 );
	}
}

function gr_print( cx:int, cy:int, data:int8*, width:int, height:int ):void
{
	var y:int;
	var i = 0;
	for( y, 0, height ){
		gr_add( gr_pos( cx, cy+y), &data[i], width );
		i += width;
	}
}

const EN_PROCESS: void(int)[] = [en_none_process, en_1_process, billy_process];
